<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>src\axis\LogarithmicAxis.es6 - EJSCharts</title>
    <link href="../assets/vendor/bootstrap/bootstrap-4.5.0.min.css" rel="stylesheet" />
    <link href="../assets/vendor/prettify/prettify-min.css" rel="stylesheet" />
    <link href="../assets/css/theme.css" rel="stylesheet" />
    <script src="../assets/vendor/jquery/jquery-3.5.1.min.js"></script>
    <script src="../assets/vendor/bootstrap/bootstrap-4.5.0.bundle.min.js"></script>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script src="../assets/js/theme.js"></script>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png" />
  </head>
  <body>
    <nav class="bg-light border-bottom navbar navbar-expand-lg navbar-light sticky-top">
      <div class="container">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#nav" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="nav">
          <h1 class="navbar-brand">EJSCharts</h1>
          <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" data-toggle="dropdown">API Docs for Version: <b>3.0.0</b></a>
              <div class="dropdown-menu">
                <a class="dropdown-item">3.0.0</a>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-3">
          <div class="card">
            <h2 class="card-header">
              API
            </h2>
            <div class="card-body">
              <ul class="list-unstyled">
                  <li><a href="../classes/EJSC.html">EJSC</a></li>
                  <li><a href="../classes/EJSC.AreaSeries.html">EJSC.AreaSeries</a></li>
                  <li><a href="../classes/EJSC.BarSeries.html">EJSC.BarSeries</a></li>
                  <li><a href="../classes/EJSC.Chart.html">EJSC.Chart</a></li>
                  <li><a href="../classes/EJSC.DateFormatter.html">EJSC.DateFormatter</a></li>
                  <li><a href="../classes/EJSC.Drawing.html">EJSC.Drawing</a></li>
                  <li><a href="../classes/EJSC.LinearAxis.html">EJSC.LinearAxis</a></li>
                  <li><a href="../classes/EJSC.LineSeries.html">EJSC.LineSeries</a></li>
                  <li><a href="../classes/EJSC.LogarithmicAxis.html">EJSC.LogarithmicAxis</a></li>
                  <li><a href="../classes/EJSC.NumberFormatter.html">EJSC.NumberFormatter</a></li>
                  <li><a href="../classes/EJSC.ScatterSeries.html">EJSC.ScatterSeries</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="col-9">
          <form class="alert alert-secondary bg-light options text-right">
            Show:
            <label for="api-show-inherited" class="checkbox">
              <input type="checkbox" id="api-show-inherited" checked>
              Inherited
            </label>
            <label for="api-show-protected" class="checkbox">
              <input type="checkbox" id="api-show-protected">
              Protected
            </label>
            <label for="api-show-private" class="checkbox">
              <input type="checkbox" id="api-show-private">
              Private
            </label>
            <label for="api-show-deprecated" class="checkbox">
              <input type="checkbox" id="api-show-deprecated">
              Deprecated
            </label>
          </form>
          <div class="apidocs">
            <div id="docs-main">
              <div class="content">
                <div class="card">
                  <div class="card-header">
                    <h3>src\axis\LogarithmicAxis.es6 <small class="float-right">File</small></h3>
                  </div>
                  <pre class="card-body prettyprint linenums">import $Array from &#x27;../util/Array.es6&#x27;;
                import $Number from &#x27;../util/Number.es6&#x27;;
                import $Object from &#x27;../util/Object.es6&#x27;;
                import EJSC from &#x27;../EJSC.es6&#x27;;
                import Axis from &#x27;./base/Axis.es6&#x27;;
                
                /**
                 * LogarithmicAxis is an axis using a logarithmic scale.
                 *
                 * @example
                 *   &#x60;&#x60;&#x60;
                 *   // TODO:
                 *   &#x60;&#x60;&#x60;
                 *
                 * @class EJSC.LogarithmicAxis
                 * @extends EJSC.Axis
                 * @constructor
                 * @param {Object} options The config options
                 * @since @todo
                 */
                export default EJSC[&#x27;sparkline&#x27;].LogarithmicAxis = class LogarithmicAxis extends Axis {
                  /**
                   * Defines the base for the logarithmic scale.
                   *
                   * @attribute {Number} base
                   * @default 10
                   * @since @todo
                   */
                
                  // getter
                  getBase() {
                    // Return the current base
                    return this.base;
                  }
                
                  // setter
                  setBase(base) {
                    // Update the current base
                    this.base = base;
                
                    // Redraw the chart if needed
                    if (this.listening) {
                      this.update();
                    }
                  }
                
                  /**
                   *
                   *
                   * @property {Object} logPoints
                   * @property {Number} logPoints.maxPositive (Default: null)
                   * @property {Number} logPoints.minPositive (Default: null)
                   * @property {Number} logPoints.zeroValue (Default: null)
                   * @property {Number} logPoints.maxNegative (Default: null)
                   * @property {Number} logPoints.minNegative (Default: null)
                   * @private
                   * @since @todo
                   */
                
                  // init
                  init() {
                    // super
                    super.init();
                
                    // Initialize some public properties
                    this.base = 10;
                
                    // Initialize some private properties
                    this.logPoints = {
                      maxPositive: null,
                      minPositive: null,
                      zeroValue: null,
                      maxNegative: null,
                      minNegative: null
                    };
                  }
                
                  /**
                   * Calculates the extremes for the axis.
                   *
                   * @method calculateExtremes
                   * @private
                   * @since @todo
                   */
                  calculateExtremes() {
                    // Grab some local pointers
                    let { drawArea, orientation, padding, extremes, logPoints } = this;
                    let visibleSeries = this.getVisibleSeries();
                
                    // Define some local variables
                    let dataPoint = orientation === &#x27;vertical&#x27; ? &#x27;y&#x27; : &#x27;x&#x27;;
                    let spacing = 0;
                    let min = null;
                    let max = null;
                    let maxPositive = null;
                    let minPositive = null;
                    let zeroValue = null;
                    let maxNegative = null;
                    let minNegative = null;
                    let scale;
                    let linearMin;
                    let linearMax;
                
                    // Reset the extremes
                    $Object.merge(extremes, {
                      min: null,
                      max: null
                    });
                
                    // Reset the log points
                    $Object.merge(logPoints, {
                      maxPositive: null,
                      minPositive: null,
                      zeroValue: null,
                      maxNegative: null,
                      minNegative: null
                    });
                
                    // If there are no visible series, we can&#x27;t calculate the extremes
                    if (visibleSeries.length &lt;= 0) {
                      return;
                    }
                
                    // Loop through each of the visible series
                    $Array.forEach(visibleSeries, series =&gt; {
                      // Calculate the min and max range
                      $Array.forEach(series.data, point =&gt; {
                        $Object(series.dataPoints[dataPoint]).forEach(property =&gt; {
                          // Calculate the extremes
                          min = $Number.min(min, point[property]);
                          max = $Number.max(max, point[property]);
                
                          // Calculate the log points
                          if (point[property] &gt; 0) {
                            maxPositive = $Number.max(maxPositive, point[property]);
                            minPositive = $Number.min(minPositive, point[property]);
                          }
                          else if (point[property] === 0) {
                            zeroValue = 0;
                          }
                          else if (point[property] &lt; 0) {
                            maxNegative = $Number.max(maxNegative, point[property]);
                            minNegative = $Number.min(minNegative, point[property]);
                          }
                        });
                      });
                
                      // Calculate the series spacing
                      spacing = $Number.max(spacing, series.calculateSpacing());
                    });
                
                    if (!$Object.isNil(zeroValue) || (!$Object.isNil(minPositive) &amp;&amp; !$Object.isNil(maxNegative))) {
                      // Make sure the zero value is defined
                      zeroValue = 0;
                
                      // Move minPositive and maxNegative to closest power
                      minPositive = this.convertPowerToPoint(Math.floor(this.convertPointToPower(minPositive)));
                      maxNegative = -this.convertPowerToPoint(Math.floor(this.convertPointToPower(-maxNegative)));
                    }
                
                    // Reset the log points
                    $Object.merge(logPoints, { maxPositive, minPositive, zeroValue, maxNegative, minNegative });
                
                    // Add the series spacing to the padding
                    padding += spacing - 1;
                
                    linearMin = this.convertPointToLinear(min);
                    linearMax = this.convertPointToLinear(max);
                
                    // Determine the scale based on the axis&#x27; orientation
                    switch (orientation) {
                      case &#x27;horizontal&#x27;:
                        scale = ((linearMax - linearMin) / (drawArea.right - drawArea.left - (padding * 2)));
                        break;
                
                      case &#x27;vertical&#x27;:
                        scale = ((linearMax - linearMin) / (drawArea.bottom - drawArea.top - (padding * 2)));
                        break;
                    }
                
                    // Update the extremes with padding
                    min = this.convertLinearToPoint(linearMin - (scale * padding));
                    max = this.convertLinearToPoint(linearMax + (scale * padding));
                
                    // Store the extremes
                    $Object.merge(extremes, { min, max });
                  }
                
                    /**
                     * Calculates the axis&#x27; ticks based on the attached series&#x27; data.
                     *
                     * @method calculateTicks
                     * @private
                     * @return {Array} The list of ticks
                     * @since @todo
                     */
                  calculateTicks() {
                    // Grab some local pointers
                    let zoom = this.getCurrentZoom();
                    let min = this.convertPointToLinear(zoom.min);
                    let max = this.convertPointToLinear(zoom.max);
                
                    // Define some local variables
                    let ticks = [];
                    let i;
                
                    // Loop through adding a tick at each power
                    for (i = Math.ceil(min); i &lt;= Math.floor(max); i++) {
                      ticks.push(this.convertLinearToPoint(i));
                    }
                
                    // Return the list of ticks
                    return ticks;
                  }
                
                  /**
                   * Converts a linear point to a logarithmic point.
                   *
                   * @method convertLinearToPoint
                   * @private
                   * @param {Number} linear The linear point
                   * @return {Number} The logarithmic point
                   * @since @todo
                   */
                  convertLinearToPoint(linear) {
                    // TODO:
                    let { minPositive, maxNegative } = this.logPoints;
                
                    // TODO:
                    let point;
                
                    // Convert 0 to 0
                    if (linear === 0) {
                      point = 0;
                    }
                
                    // TODO:
                    else if (linear &gt; 0 &amp;&amp; linear &lt; 1) {
                      // TODO
                    }
                
                    // TODO:
                    else if (linear &lt; 0 &amp;&amp; linear &gt; -1) {
                      // TODO:
                    }
                
                    // TODO
                    else if (linear &gt;= 1) {
                      point = this.convertPowerToPoint(linear - 1 + this.convertPointToPower(minPositive));
                    }
                
                    // TODO:
                    else if (linear &lt;= -1) {
                      point = -(this.convertPowerToPoint(-linear - 1 + this.convertPointToPower(-maxNegative)));
                    }
                
                    // Return the point value
                    return point;
                  }
                
                  /**
                   * Converts a chart pixel to a logarithmic point.
                   *
                   * @method convertPixelToPoint
                   * @private
                   * @param {Number} pixel The chart pixel
                   * @return {Number} The logarithmic point
                   * @since @todo
                   */
                  convertPixelToPoint(pixel) {
                    // Grab some local pointers
                    let drawArea = this.drawArea;
                    let zoom = this.getCurrentZoom();
                
                    // Define some local variables
                    let pixelMin;
                    let pixelMax;
                    let pixelDif;
                    let pixelPerc;
                    let linearMin = this.convertPointToLinear(zoom.min);
                    let linearMax = this.convertPointToLinear(zoom.max);
                    let linearDif = linearMax - linearMin;
                    let point = null;
                
                    // There needs to be a current zoom to convert
                    if (linearMin !== null &amp;&amp; linearMax !== null) {
                      // Calculate the coordinate based on the axis&#x27; orientation
                      switch (this.orientation) {
                        case &#x27;horizontal&#x27;:
                          pixelMin = drawArea.left;
                          pixelMax = drawArea.right - 1;
                          pixelDif = pixelMax - pixelMin;
                          pixelPerc = ((pixel - pixelMin) / pixelDif);
                
                          if (this.reverse === false) {
                            point = this.convertLinearToPoint(linearMin + (linearDif * pixelPerc));
                          }
                          else {
                            point = this.convertLinearToPoint(linearMax - (linearDif * pixelPerc));
                          }
                
                          break;
                
                        case &#x27;vertical&#x27;:
                          pixelMin = drawArea.top;
                          pixelMax = drawArea.bottom - 1;
                          pixelDif = pixelMax - pixelMin;
                          pixelPerc = ((pixel - pixelMin) / pixelDif);
                
                          if (this.reverse === false) {
                            point = this.convertLinearToPoint(linearMax - (linearDif * pixelPerc));
                          }
                          else {
                            point = this.convertLinearToPoint(linearMin + (linearDif * pixelPerc));
                          }
                
                          break;
                      }
                    }
                
                    // Return the point
                    return point;
                  }
                
                  /**
                   * Converts a logarithmic point to a linear point.
                   *
                   * @method convertPointToLinear
                   * @private
                   * @param {Number} point The logarithmic point
                   * @return {Number} The linear point
                   * @since @todo
                   */
                  convertPointToLinear(point) {
                    // TODO:
                    let { minPositive, maxNegative } = this.logPoints;
                
                    // TODO:
                    let linear;
                
                    // Convert 0 to 0
                    if (point === 0) {
                      linear = 0;
                    }
                
                    // TODO:
                    else if (point &gt; 0 &amp;&amp; point &lt; minPositive) {
                      // TODO:
                    }
                
                    // TODO:
                    else if (point &lt; 0 &amp;&amp; point &gt; maxNegative) {
                      // TODO:
                    }
                
                    // Calculate the power difference for positive values above minPositive
                    else if (point &gt;= minPositive) {
                      linear = this.convertPointToPower(point) - this.convertPointToPower(minPositive) + 1;
                    }
                
                    // Calculate the power difference for negative values below maxNegative
                    else if (point &lt;= maxNegative) {
                      linear = -(this.convertPointToPower(-point) - this.convertPointToPower(-maxNegative) + 1);
                    }
                
                    // Return the linear value
                    return linear;
                  }
                
                  /**
                   * Converts a logarithmic point to a chart pixel.
                   *
                   * @method convertPointToPixel
                   * @private
                   * @param {Number} point The logarithmic point
                   * @return {Number} The chart pixel
                   * @since @todo
                   */
                  convertPointToPixel(point) {
                    // Grab some local pointers
                    let drawArea = this.drawArea;
                    let zoom = this.getCurrentZoom();
                
                    // Define some local variables
                    let linearMin = this.convertPointToLinear(zoom.min);
                    let linearMax = this.convertPointToLinear(zoom.max);
                    let linearPerc = ((this.convertPointToLinear(point) - linearMin) / (linearMax - linearMin));
                    let pixelMin;
                    let pixelMax;
                    let pixelDif;
                    let pixel = null;
                
                    // There needs to be a current zoom to convert
                    if (linearMin !== null &amp;&amp; linearMax !== null) {
                      // Determine the coordinate based on the axis&#x27; orientation
                      switch (this.orientation) {
                        case &#x27;horizontal&#x27;:
                          pixelMin = drawArea.left;
                          pixelMax = drawArea.right - 1;
                          pixelDif = pixelMax - pixelMin;
                
                          if (this.reverse === false) {
                            pixel = pixelMin + (pixelDif * linearPerc);
                          }
                          else {
                            pixel = pixelMax - (pixelDif * linearPerc);
                          }
                
                          break;
                
                        case &#x27;vertical&#x27;:
                          pixelMin = drawArea.top;
                          pixelMax = drawArea.bottom - 1;
                          pixelDif = pixelMax - pixelMin;
                
                          if (this.reverse === false) {
                            pixel = pixelMax - (pixelDif * linearPerc);
                          }
                          else {
                            pixel = pixelMin + (pixelDif * linearPerc);
                          }
                
                          break;
                      }
                    }
                
                    // Return the pixel
                    return pixel;
                  }
                
                  /**
                   * Converts a logarithmic point to a power of the base.
                   *
                   * @method convertPointToPower
                   * @private
                   * @param {Number} point The logarithmic point
                   * @return {Number} The poser of the base
                   * @since @todo
                   */
                  convertPointToPower(point) {
                    // Return the power value
                    return Math.log(point) / Math.log(this.base);
                  }
                
                  /**
                   * Converts a logarithmic point to a power of the base.
                   *
                   * @method convertPowerToPoint
                   * @private
                   * @param {Number} power The poser of the base
                   * @return {Number} The logarithmic point
                   * @since @todo
                   */
                  convertPowerToPoint(power) {
                    // Return the point value
                    return Math.pow(this.base, power);
                  }
                };
                </pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
