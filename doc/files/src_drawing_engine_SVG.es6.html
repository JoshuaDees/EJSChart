<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>src\drawing\engine\SVG.es6 - EJSCharts</title>
    <link href="../assets/vendor/bootstrap/bootstrap-4.5.0.min.css" rel="stylesheet" />
    <link href="../assets/vendor/prettify/prettify-min.css" rel="stylesheet" />
    <link href="../assets/css/theme.css" rel="stylesheet" />
    <script src="../assets/vendor/jquery/jquery-3.5.1.min.js"></script>
    <script src="../assets/vendor/bootstrap/bootstrap-4.5.0.bundle.min.js"></script>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script src="../assets/js/theme.js"></script>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png" />
  </head>
  <body>
    <nav class="bg-light border-bottom navbar navbar-expand-lg navbar-light sticky-top">
      <div class="container">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#nav" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="nav">
          <h1 class="navbar-brand">EJSCharts</h1>
          <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" data-toggle="dropdown">API Docs for Version: <b>3.0.0</b></a>
              <div class="dropdown-menu">
                <a class="dropdown-item">3.0.0</a>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-3">
          <div class="card">
            <h2 class="card-header">
              API
            </h2>
            <div class="card-body">
              <ul class="list-unstyled">
                  <li><a href="../classes/EJSC.html">EJSC</a></li>
                  <li><a href="../classes/EJSC.AreaSeries.html">EJSC.AreaSeries</a></li>
                  <li><a href="../classes/EJSC.BarSeries.html">EJSC.BarSeries</a></li>
                  <li><a href="../classes/EJSC.Chart.html">EJSC.Chart</a></li>
                  <li><a href="../classes/EJSC.DateFormatter.html">EJSC.DateFormatter</a></li>
                  <li><a href="../classes/EJSC.Drawing.html">EJSC.Drawing</a></li>
                  <li><a href="../classes/EJSC.LinearAxis.html">EJSC.LinearAxis</a></li>
                  <li><a href="../classes/EJSC.LineSeries.html">EJSC.LineSeries</a></li>
                  <li><a href="../classes/EJSC.LogarithmicAxis.html">EJSC.LogarithmicAxis</a></li>
                  <li><a href="../classes/EJSC.NumberFormatter.html">EJSC.NumberFormatter</a></li>
                  <li><a href="../classes/EJSC.ScatterSeries.html">EJSC.ScatterSeries</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="col-9">
          <form class="alert alert-secondary bg-light options text-right">
            Show:
            <label for="api-show-inherited" class="checkbox">
              <input type="checkbox" id="api-show-inherited" checked>
              Inherited
            </label>
            <label for="api-show-protected" class="checkbox">
              <input type="checkbox" id="api-show-protected">
              Protected
            </label>
            <label for="api-show-private" class="checkbox">
              <input type="checkbox" id="api-show-private">
              Private
            </label>
            <label for="api-show-deprecated" class="checkbox">
              <input type="checkbox" id="api-show-deprecated">
              Deprecated
            </label>
          </form>
          <div class="apidocs">
            <div id="docs-main">
              <div class="content">
                <div class="card">
                  <div class="card-header">
                    <h3>src\drawing\engine\SVG.es6 <small class="float-right">File</small></h3>
                  </div>
                  <pre class="card-body prettyprint linenums">import $Object from &#x27;../../util/Object.es6&#x27;;
                import EJSC from &#x27;../../EJSC.es6&#x27;;
                import Drawing from &#x27;../Drawing.es6&#x27;;
                import Engine from &#x27;./base/Engine.es6&#x27;;
                
                /**
                 * Defines the SVG rendering engine for EJSCharts.
                 *
                 * @class EJSC.SVG
                 * @constructor
                 * @private
                 * @extends EJSC.Engine
                 * @since @todo
                 */
                export default EJSC.SVG = class SVG extends Engine {
                  /**
                   * Holds a pointer to the engine&#x27;s background dom element.
                   *
                   * @property {Element} background.
                   * @private
                   * @default null
                   * @since @todo
                   */
                
                  /**
                   * Holds a current clip id.
                   *
                   * @property {String} clipId
                   * @private
                   * @default null
                   * @since @todo
                   */
                
                  /**
                   * Holds the current clip index.
                   *
                   * @property {Integer} clipIndex
                   * @private
                   * @default null
                   * @since @todo
                   */
                
                  /**
                   * Holds a pointer to the engine&#x27;s definitions dom element.
                   *
                   * @property {Element} definitions
                   * @private
                   * @default null
                   * @since @todo
                   */
                
                  /**
                   * Holds the current drawing path.
                   *
                   * @property {Array} path
                   * @private
                   * @default []
                   * @since @todo
                   */
                
                  /**
                   * Draws an arc at a point.
                   *
                   * @method arc
                   * @param {Number} cx The x coordinate of the center
                   * @param {Number} cy The y coordinate of the center
                   * @param {Number} radius The radius of the arc
                   * @param {Number} startAngle The start angle (in radians)
                   * @param {Number} endAngle The end angle (in radians)
                   * @param {Boolean} counterClockwise Whether to draw this counter-clockwise
                   * @since @todo
                   */
                  arc(cx, cy, radius, startAngle, endAngle, counterClockwise) {
                    // Define needed points
                    let x1 = cx + (radius * Math.cos(startAngle));
                    let y1 = cy + (radius * Math.sin(startAngle));
                    let x2 = cx + (radius * Math.cos(endAngle));
                    let y2 = cy + (radius * Math.sin(endAngle));
                
                    // Determine the direction from the angles
                    let direction = (startAngle &lt; endAngle ? 0 : 1);
                
                    // Define the arc flags
                    let largeArc = (counterClockwise ? 1 - direction : direction);
                    let sweep = (counterClockwise ? 0 : 1);
                
                    // Move to starting point
                    this.path.push(($Object.isNull(this.drawing.lastPoint[0]) ? &#x27;M&#x27; : &#x27;L&#x27;) + &#x27; &#x27; + x1 + &#x27;,&#x27; + y1);
                
                    // Append to path object
                    this.path.push(&#x27;A &#x27; + radius + &#x27;,&#x27; + radius + &#x27; &#x27; + 0 + &#x27; &#x27; + largeArc + &#x27; &#x27; + sweep + &#x27; &#x27; + x2 + &#x27;,&#x27; + y2);
                  }
                
                  /**
                   * Draws an arc stemming using a control point to an end point.
                   *
                   * @method arcTo
                   * @param {Number} cpx The x coordinate of the control point
                   * @param {Number} cpy The y coordinate of the control point
                   * @param {Number} x The x coordinate of the end point
                   * @param {Number} y The y coordinate of the end point
                   * @param {Number} radius The radius of the arc
                   * @since @todo
                   */
                  arcTo(cpx, cpy, x, y, radius) {
                    // Grab last points
                    let x0 = this.drawing.lastPoint[0];
                    let y0 = this.drawing.lastPoint[1];
                
                    // Find the angle of each section
                    let firstAngle = (Math.PI / 2) - Math.atan2((cpy - y0), (cpx - x0));
                    let secondAngle = (Math.PI / 2) - Math.atan2((cpy - y), (cpx - x));
                    let centerAngle = (firstAngle + secondAngle) / 2;
                
                    // Find the length of the triangle&#x27;s hypotenuse
                    let hypotenuse = radius / Math.sin(-Math.abs(centerAngle - firstAngle));
                    let adjacent = Math.sqrt((hypotenuse * hypotenuse) - (radius * radius));
                
                    // Get the center coordinates for the circle
                    let cx = cpx + (Math.sin(centerAngle) * hypotenuse);
                    let cy = cpy + (Math.cos(centerAngle) * hypotenuse);
                
                    // Get the cross coordinates for the circle&#x27;s points
                    let cx1 = cpx - (Math.sin(firstAngle) * adjacent);
                    let cy1 = cpy - (Math.cos(firstAngle) * adjacent);
                    let cx2 = cpx - (Math.sin(secondAngle) * adjacent);
                    let cy2 = cpy - (Math.cos(secondAngle) * adjacent);
                
                    // Build the new angles
                    let startAngle = Math.atan2((cy1 - cy), (cx1 - cx));
                    let endAngle = Math.atan2((cy2 - cy), (cx2 - cx));
                
                    // Draw the connecting line
                    this[($Object.isNull(this.drawing.lastPoint[0]) ? &#x27;moveTo&#x27; : &#x27;lineTo&#x27;)](cx1, cy1);
                
                    // Draw the arc
                    this.arc(cx, cy, radius, startAngle, endAngle, firstAngle &gt; secondAngle);
                  }
                
                  /**
                   * Begins clippig the given area.
                   *
                   * @method beginClip
                   * @param {Number} left The left coordinate of the clip area
                   * @param {Number} top The top coordinate of the clip area
                   * @param {Number} width The width of the clip area
                   * @param {Number} height The height of the clip area
                   * @since @todo
                   */
                  beginClip(x, y, width, height) {
                    // Build the clip id
                    let clipId = &#x27;clip-&#x27; + (this.clipIndex++);
                
                    // Create the clip definition
                    let clipPath = this.definitions.appendChild(this.createElement(&#x27;clipPath&#x27;, {
                      id: clipId
                    }));
                
                    // Append the clip area
                    clipPath.appendChild(this.createElement(&#x27;rect&#x27;, {
                      x,
                      y,
                      width,
                      height
                    }));
                
                    // Store the clip id
                    this.clipId = clipId;
                  }
                
                  /**
                   * Begins a new path.
                   *
                   * @method beginPath
                   * @since @todo
                   */
                  beginPath() {
                    // Reset the current path
                    this.path = [];
                  }
                
                  /**
                   * Draws a bezier curve.
                   *
                   * @method bezierCurveTo
                   * @param {Number} cp1x The x coordinate of the first control point
                   * @param {Number} cp1y The y coordinate of the first control point
                   * @param {Number} cp2x The x coordinate of the second control point
                   * @param {Number} cp2y The y coordinate of the second control point
                   * @param {Number} x The end x coordinate of the curve
                   * @param {Number} y The end y coordinate of the curve
                   * @since @todo
                   */
                  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
                    // Append to path object
                    this.path.push(&#x27;C &#x27; + cp1x + &#x27;,&#x27; + cp1y + &#x27; &#x27; + cp2x + &#x27;,&#x27; + cp2y + &#x27; &#x27; + x + &#x27;,&#x27; + y);
                  }
                
                  /**
                   * Draws a circle on the canvas.
                   *
                   * @method circle
                   * @param {Number} x The x coordinate for the center of the circle
                   * @param {Number} y The y coordinate for the center of the circle
                   * @param {Number} radius The radius (in px) of the circle
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  circle(cx, cy, radius, styles) {
                    // Create the circle element
                    this.element.appendChild(this.createElement(&#x27;circle&#x27;, $Object.merge(this.stylize(styles), {
                      cx,
                      cy,
                      r: radius
                    })));
                  }
                
                  /**
                   * Clears the canvas.
                   *
                   * @method clear
                   * @since @todo
                   */
                  clear() {
                    // Clear out all of the elements (except for the definitions and background)
                    while (this.element.childNodes.length &gt; 2) {
                      this.element.removeChild(this.element.lastChild);
                    }
                
                    // Clear out all of the definitions
                    while (this.definitions.childNodes.length &gt; 0) {
                      this.definitions.removeChild(this.definitions.lastChild);
                    }
                
                    // Clear out the clip variables
                    this.clipId = null;
                    this.clipIndex = 0;
                  }
                
                  /**
                   * Closes the current path.
                   *
                   * @method clear
                   * @since @todo
                   */
                  closePath() {
                    // Append to path object
                    this.path.push(&#x27;Z&#x27;);
                  }
                
                  /**
                   * Fills and strokes the given path on the canvas.
                   *
                   * @method draw
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  draw(styles) {
                    this.drawPath(this.stylize(styles));
                  }
                
                  /**
                   * Draws a ellipse.
                   *
                   * @method ellipse
                   * @param {Number} x The x coordinate to start the ellipse at
                   * @param {Number} y The y coordinate to start the ellipse at
                   * @param {Number} rx The x radius of the ellipse
                   * @param {Number} ry The y radius of the ellipse
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  ellipse(cx, cy, rx, ry, styles) {
                    // Create the ellipse element
                    this.element.appendChild(this.createElement(&#x27;ellipse&#x27;, $Object.merge(this.stylize(styles), {
                      cx,
                      cy,
                      rx,
                      ry
                    })));
                  }
                
                  /**
                   * Ends the current clipping of the canvas&#x27; drawing area.
                   *
                   * @method endClip
                   * @since @todo
                   */
                  endClip() {
                    // Clear the clip id
                    this.clipId = null;
                  }
                
                  /**
                   * Fills the given path on the canvas.
                   *
                   * @method fill
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  fill(styles) {
                    this.drawPath($Object.merge(this.stylize(styles), {
                      strokeStyle: &#x27;transparent&#x27;
                    }));
                  }
                
                  /**
                   * Draws a horizontal line to a new position.
                   *
                   * @method horizontalTo
                   * @param {Number} x The x coordinate to draw to
                   * @since @todo
                   */
                  horizontalTo(x) {
                    // Append to path object
                    this.path.push(&#x27;H &#x27; + x);
                  }
                
                  /**
                   * Draws a line between two points.
                   *
                   * @method line
                   * @param {Number} x1 The x coordinate for the starting point
                   * @param {Number} y1 The y coordinate for the starting point
                   * @param {Number} x2 The x coordinate for the ending point
                   * @param {Number} y2 The y coordinate for the ending point
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  line(x1, y1, x2, y2, styles) {
                    // Create the line element
                    this.element.appendChild(this.createElement(&#x27;line&#x27;, $Object.merge(this.stylize(styles), {
                      x1,
                      y1,
                      x2,
                      y2
                    })));
                  }
                
                  /**
                   * Draws a line to a new position.
                   *
                   * @method lineTo
                   * @param {Number} x The x coordinate to draw to
                   * @param {Number} y The y coordinate to draw to
                   * @since @todo
                   */
                  lineTo(x, y) {
                    // Append to path object
                    this.path.push(&#x27;L &#x27; + x + &#x27;,&#x27; + y);
                  }
                
                  /**
                   * Measures the width of the given text.
                   *
                   * @method measureText
                   * @param {String} text The text
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  measureText(text, styles) {
                    // TODO:
                    return [text, styles];
                  }
                
                  /**
                   * Moves the pen to a new position.
                   *
                   * @method moveTo
                   * @param {Number} x The x coordinate to move to
                   * @param {Number} y The y coordinate to move to
                   * @since @todo
                   */
                  moveTo(x, y) {
                    // Append to path object
                    this.path.push(&#x27;M &#x27; + x + &#x27;,&#x27; + y);
                  }
                
                  /**
                   * Draws a quadratic curve.
                   *
                   * @method quadraticCurveTo
                   * @param {Number} cpx The x coordinate of the control point
                   * @param {Number} cpy The y coordinate of the control point
                   * @param {Number} x The end x coordinate of the curve
                   * @param {Number} y The end y coordinate of the curve
                   * @since @todo
                   */
                  quadraticCurveTo(cpx, cpy, x, y) {
                    // Append to path object
                    this.path.push(&#x27;Q &#x27; + cpx + &#x27;,&#x27; + cpy + &#x27; &#x27; + x + &#x27;,&#x27; + y);
                  }
                
                  /**
                   * Draws a rectanle on the canvas.
                   *
                   * @method rect
                   * @param {Number} x The x coordinate to start at
                   * @param {Number} y The y coordinate to start at
                   * @param {Number} width The width of the rectangle
                   * @param {Number} height The height of the rectangle
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  rect(x, y, width, height, styles) {
                    // Create the rect element
                    this.element.appendChild(this.createElement(&#x27;rect&#x27;, $Object.merge(this.stylize(styles), {
                      x,
                      y,
                      width,
                      height
                    })));
                  }
                
                  /**
                   * Resizes the canvas.
                   *
                   * @method resize
                   * @param {Integer} width The new width for the canvas
                   * @param {Integer} height The new height for the canvas
                   * @since @todo
                   */
                  resize(width, height) {
                    // Set the width and height attributes of the main element
                    this.element.setAttribute(&#x27;width&#x27;, width);
                    this.element.setAttribute(&#x27;height&#x27;, height);
                
                    // Set the viewbox attribute of the main element
                    this.element.setAttribute(&#x27;viewBox&#x27;, &#x27;0 0 &#x27; + width + &#x27; &#x27; + height);
                
                    // Set the width and height attributes of the background element
                    this.background.setAttribute(&#x27;width&#x27;, width);
                    this.background.setAttribute(&#x27;height&#x27;, height);
                  }
                
                  /**
                   * Draws a stroke along the current drawing path.
                   *
                   * @method stroke
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  stroke(styles) {
                    // Stroke the path
                    this.drawPath($Object.merge(this.stylize(styles), {
                      fillStyle: &#x27;transparent&#x27;
                    }));
                  }
                
                  /**
                   * Draws text on the canvas.
                   *
                   * @method text
                   * @param {String} text The text to draw on the canvas
                   * @param {Number} x The x coordinate to draw the text at
                   * @param {Number} y The y coordinate to draw the text at
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  text(text, x, y, styles) {
                    // Build the correct styles object
                    styles = $Object.merge({}, this.stylize(styles), {
                      strokeStyle: &#x27;none&#x27;,
                      x,
                      y
                    });
                
                    // Create the text element
                    let el = this.element.appendChild(this.createElement(&#x27;text&#x27;, styles));
                    el.setAttribute(&#x27;transform&#x27;, &#x27;rotate(&#x27; + styles.textRotation + &#x27; &#x27; + x + &#x27; &#x27; + y + &#x27;)&#x27;);
                    el.appendChild(document.createTextNode(text));
                  }
                
                  /**
                   * Draws a vertical line to a new position.
                   *
                   * @method verticalTo
                   * @param {Number} y The y coordinate to draw to
                   * @since @todo
                   */
                  verticalTo(y) {
                    // Append to path object
                    this.path.push(&#x27;V &#x27; + y);
                  }
                
                  // constructor
                  constructor() {
                    // super
                    super();
                
                    // Create a document fragment to temporarily hold the DOM Elements
                    let frag = document.createDocumentFragment();
                
                    // Create the main element
                    this.element = frag.appendChild(this.createElement(&#x27;svg&#x27;, {
                      &#x27;xmlns&#x27;: EJSC.SVG.xmlns,
                      &#x27;version&#x27;: &#x27;1.1&#x27;
                    }));
                    this.element.setAttributeNS(EJSC.SVG.xmlns, &#x27;xmlns:xlink&#x27;, EJSC.SVG.xlink);
                
                    // Create the definitions element
                    this.definitions = this.element.appendChild(this.createElement(&#x27;defs&#x27;));
                
                    // Create the background element
                    this.background = this.element.appendChild(this.createElement(&#x27;rect&#x27;, {
                      x: 0,
                      y: 0,
                      fill: &#x27;transparent&#x27;
                    }));
                
                    // Create a global stylesheet (only once) to restrict user selection
                    EJSC.SVG.buildStylesheet();
                  }
                
                  // init
                  init() {
                    // Initialize the private properties
                    this.background = null;
                    this.clipId = null;
                    this.clipIndex = 0;
                    this.definitions = null;
                    this.path = [];
                  }
                
                  /**
                   * Creates an SVG elemen.
                   *
                   * @method createElement
                   * @param {String} tagName The type of element to create
                   * @param {Object} attributes The attributes to add to the element
                   * @return {Element}
                   * @since @todo
                   */
                  createElement(tagName, attributes) {
                    // Create an element using the given tagName
                    let el = document.createElementNS(EJSC.SVG.svgns, tagName);
                
                    // Set the given attributes to the element
                    for (let i in attributes) {
                      // If this is direct css
                      if (i === &#x27;css&#x27;) {
                        el.style.cssText = attributes[i];
                      }
                
                      // If this is the font attribute, set it using CSS
                      else if (i === &#x27;font&#x27;) {
                        el.style.cssText = &#x27;font: &#x27; + attributes.font + &#x27; !important;&#x27;;
                      }
                
                      // If this is the text-align attribute
                      else if (i === &#x27;textAlign&#x27;) {
                        el.setAttribute(&#x27;text-anchor&#x27;, ({
                          &#x27;left&#x27;: &#x27;start&#x27;,
                          &#x27;center&#x27;: &#x27;middle&#x27;,
                          &#x27;right&#x27;: &#x27;end&#x27;
                        })[attributes[i]]);
                      }
                
                      // If this is the rotate attribute, don&#x27;t set it
                      else if (i === &#x27;textRotation&#x27;) {
                        // Do nothing
                      }
                
                      // If this is the text-baseline attribute, set it using custom attributes
                      else if (i === &#x27;textBaseline&#x27;) {
                        el.style.dominantBaseline = ({
                          &#x27;top&#x27;: &#x27;hanging&#x27;,
                          &#x27;middle&#x27;: &#x27;middle&#x27;,
                          &#x27;bottom&#x27;: &#x27;baseline&#x27;
                        })[attributes[i]];
                      }
                
                      // If this is the same as the default attribute
                      else if (attributes[i] === Drawing.defaults[i] &amp;&amp; i !== &#x27;strokeStyle&#x27; &amp;&amp; i !== &#x27;fillStyle&#x27;) {
                        // Do nothing
                      }
                
                      // Set the attribute to the element
                      else {
                        el.setAttribute(EJSC.SVG.styles[i] || i, attributes[i]);
                      }
                    }
                
                    if (this.clipId !== null) {
                      el.setAttribute(&#x27;clip-path&#x27;, &#x27;url(#&#x27; + this.clipId + &#x27;)&#x27;);
                    }
                
                    // Return the element
                    return el;
                  }
                
                  /**
                   * Draws the given path.
                   *
                   * @method drawPath
                   * @private
                   * @param {Object} styles The styles to apply
                   * @since @todo
                   */
                  drawPath(styles) {
                    // Create the path element
                    this.element.appendChild(this.createElement(&#x27;path&#x27;, $Object.merge(this.stylize(styles), {
                      d: this.path.join(&#x27; &#x27;)
                    })));
                  }
                
                  /**
                   * Applies the given styles to the drawing context.
                   *
                   * @method stylize
                   * @private
                   * @param {Object} styles The styles to apply
                   * @return {Object}
                   * @since @todo
                   */
                  stylize(styles) {
                    // Apply the default and user styles to the context
                    return $Object.merge({}, Drawing.defaults, styles);
                  }
                };
                
                // TODO:
                EJSC.SVG.css = &#x27;svg { overflow: hidden; } svg, svg * { user-select: none; -moz-user-select: none; -webkit-user-select: none; }&#x27;;
                
                /**
                 * Defines the style conversion names.
                 *
                 * @property {Object} styles
                 * @private
                 * @static
                 * @since @todo
                 */
                EJSC.SVG.styles = {
                  fillStyle: &#x27;fill&#x27;,
                  font: &#x27;font&#x27;,
                  lineCap: &#x27;stroke-linecap&#x27;,
                  lineDash: &#x27;stroke-dasharray&#x27;,
                  lineJoin: &#x27;stroke-linejoin&#x27;,
                  lineWidth: &#x27;stroke-width&#x27;,
                  strokeStyle: &#x27;stroke&#x27;,
                  textAlign: &#x27;text-align&#x27;,
                  textBaseline: &#x27;text-baseline&#x27;,
                  textRotation: &#x27;text-rotation&#x27;
                };
                
                /**
                 * Defines the stylesheet that holds the global SVG styles.
                 *
                 * @property {StyleSheet} stylesheet
                 * @private
                 * @static
                 * @default null
                 * @since @todo
                 */
                EJSC.SVG.stylesheet = null;
                
                /**
                 * Defines the SVG namespace.
                 *
                 * @property {String} svgns
                 * @private
                 * @static
                 * @default &#x27;http://www.w3.org/2000/svg&#x27;
                 * @since @todo
                 */
                EJSC.SVG.svgns = &#x27;http://www.w3.org/2000/svg&#x27;;
                
                /**
                 * Defines the XML namespace.
                 *
                 * @property {String} xmlns
                 * @private
                 * @static
                 * @default &#x27;http://www.w3.org/2000/xmlns/&#x27;
                 * @since @todo
                 */
                EJSC.SVG.xmlns = &#x27;http://www.w3.org/2000/xmlns/&#x27;;
                
                /**
                 * Defines the Xlink namespace.
                 *
                 * @property {String} xlink
                 * @private
                 * @static
                 * @default &#x27;http://www.w3.org/2000/xlink&#x27;
                 * @since @todo
                 */
                EJSC.SVG.xlink = &#x27;http://www.w3.org/1999/xlink&#x27;;
                
                /**
                 * Builds the default SVG stylesheet.
                 *
                 * @method buildStylesheet
                 * @private
                 * @static
                 * @since @todo
                 */
                EJSC.SVG.buildStylesheet = () =&gt; {
                  // Only run once
                  if ($Object.isNull(EJSC.SVG.stylesheet)) {
                    // Grab the page header
                    let head = document.head || document.getElementsByTagName(&#x27;head&#x27;)[0];
                
                    // Create the stylesheet
                    let stylesheet = document.createElement(&#x27;style&#x27;);
                    stylesheet.type = &#x27;text/css&#x27;;
                
                    // Set the CSS
                    if (stylesheet.styleSheet) {
                      stylesheet.styleSheet.cssText = EJSC.SVG.css;
                    }
                    else {
                      stylesheet.appendChild(document.createTextNode(EJSC.SVG.css));
                    }
                
                    // Append the styleshet to the page header
                    head.appendChild(stylesheet);
                
                    // Save the stylesheet
                    EJSC.SVG.stylesheet = stylesheet;
                  }
                };
                
                /**
                 * Determines if the browser supports SVG.
                 *
                 * @method isSupported
                 * @static
                 * @private
                 * @return {Boolean} If the browser supports SVG
                 * @since @todo
                 */
                EJSC.SVG.isSupported = () =&gt; document.implementation.hasFeature(&#x27;http://www.w3.org/TR/SVG11/feature#BasicStructure&#x27;, &#x27;1.1&#x27;);
                
                // Register the engine
                Drawing.register(&#x27;SVG&#x27;, EJSC.SVG);
                </pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
