<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>src\series\LineSeries.es6 - EJSCharts</title>
    <link href="../assets/vendor/bootstrap/bootstrap-4.5.0.min.css" rel="stylesheet" />
    <link href="../assets/vendor/prettify/prettify-min.css" rel="stylesheet" />
    <link href="../assets/css/theme.css" rel="stylesheet" />
    <script src="../assets/vendor/jquery/jquery-3.5.1.min.js"></script>
    <script src="../assets/vendor/bootstrap/bootstrap-4.5.0.bundle.min.js"></script>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script src="../assets/js/theme.js"></script>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png" />
  </head>
  <body>
    <nav class="bg-light border-bottom navbar navbar-expand-lg navbar-light sticky-top">
      <div class="container">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#nav" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="nav">
          <h1 class="navbar-brand">EJSCharts</h1>
          <ul class="navbar-nav ml-auto mt-2 mt-lg-0">
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" data-toggle="dropdown">API Docs for Version: <b>3.0.0</b></a>
              <div class="dropdown-menu">
                <a class="dropdown-item">3.0.0</a>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
      <div class="row">
        <div class="col-3">
          <div class="card">
            <h2 class="card-header">
              API
            </h2>
            <div class="card-body">
              <ul class="list-unstyled">
                  <li><a href="../classes/EJSC.html">EJSC</a></li>
                  <li><a href="../classes/EJSC.AreaSeries.html">EJSC.AreaSeries</a></li>
                  <li><a href="../classes/EJSC.BarSeries.html">EJSC.BarSeries</a></li>
                  <li><a href="../classes/EJSC.Chart.html">EJSC.Chart</a></li>
                  <li><a href="../classes/EJSC.Drawing.html">EJSC.Drawing</a></li>
                  <li><a href="../classes/EJSC.LinearAxis.html">EJSC.LinearAxis</a></li>
                  <li><a href="../classes/EJSC.LineSeries.html">EJSC.LineSeries</a></li>
                  <li><a href="../classes/EJSC.LogarithmicAxis.html">EJSC.LogarithmicAxis</a></li>
                  <li><a href="../classes/EJSC.ScatterSeries.html">EJSC.ScatterSeries</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div class="col-9">
          <form class="alert alert-secondary bg-light options text-right">
            Show:
            <label for="api-show-inherited" class="checkbox">
              <input type="checkbox" id="api-show-inherited" checked>
              Inherited
            </label>
            <label for="api-show-protected" class="checkbox">
              <input type="checkbox" id="api-show-protected">
              Protected
            </label>
            <label for="api-show-private" class="checkbox">
              <input type="checkbox" id="api-show-private">
              Private
            </label>
            <label for="api-show-deprecated" class="checkbox">
              <input type="checkbox" id="api-show-deprecated">
              Deprecated
            </label>
          </form>
          <div class="apidocs">
            <div id="docs-main">
              <div class="content">
                <div class="card">
                  <div class="card-header">
                    <h3>src\series\LineSeries.es6 <small class="float-right">File</small></h3>
                  </div>
                  <pre class="card-body prettyprint linenums">import $Array from &#x27;../util/Array.es6&#x27;;
                import $Number from &#x27;../util/Number.es6&#x27;;
                import $Object from &#x27;../util/Object.es6&#x27;;
                import EJSC from &#x27;../EJSC.es6&#x27;;
                import ScatterSeries from &#x27;./ScatterSeries.es6&#x27;;
                
                /**
                 * LineSeries is rendered by drawing a line from point to point.
                 *
                 * @example
                 *   &#x60;&#x60;&#x60;
                 *   // TODO:
                 *   &#x60;&#x60;&#x60;
                 *
                 * @class EJSC.LineSeries
                 * @extends EJSC.ScatterSeries
                 * @constructor
                 * @param {Array} data The data array
                 * @param {Object} options The config options
                 * @since @todo
                 */
                export default EJSC[&#x27;sparkline&#x27;].LineSeries = class LineSeries extends ScatterSeries {
                  /**
                   * Defines the style options for the drawn line.
                   *
                   * @example
                   *   &#x60;&#x60;&#x60;
                   *   // TODO:
                   *   &#x60;&#x60;&#x60;
                   *
                   * @attribute {Object} line
                   * @property {Integer} line.lineWidth Defines the width of the line. (Default: 1)
                   * @property {String} line.strokeStyle Defines the color of the line. (Default: null)
                   * @since @todo
                   */
                
                  // getter
                  getLine() {
                    // Return the current line
                    return this.line;
                  }
                
                  // setter
                  setLine(line) {
                    // Update the current line
                    $Object.merge(this.line, line);
                
                    // Redraw the chart if needed
                    if (this.listening) {
                      this.update();
                    }
                  }
                
                  /**
                   * Determines if the drawing routine should draw as steps.
                   *
                   * @example
                   *   &#x60;&#x60;&#x60;
                   *   // TODO:
                   *   &#x60;&#x60;&#x60;
                   *
                   * @attribute {Boolean} step
                   * @default false
                   * @since @todo
                   */
                
                  // getter
                  getStep() {
                    // Return the current step
                    return this.step;
                  }
                
                  // setter
                  setStep(step) {
                    // Update the current step
                    this.step = step;
                
                    // Redraw the chart if needed
                    if (this.listening) {
                      this.update();
                    }
                  }
                
                  // init
                  init() {
                    // super
                    super.init();
                
                    // Initialize some public properties
                    this.line = {
                      lineWidth: 1,
                      strokeStyle: null
                    };
                    this.step = false;
                  }
                
                  /**
                   * Builds the drawing path.
                   *
                   * @method buildPath
                   * @private
                   * @return {Array} The path to draw
                   * @since @todo
                   */
                  buildPath() {
                    // Grab some local pointers
                    let step = this.step;
                    let path = [];
                
                    // Build the drawing path
                    $Array.forEach(this.data, (point, index) =&gt; {
                      // Add the previous step (if needed)
                      if (index &gt; 0 &amp;&amp; step) {
                        path.push({
                          x: point.x,
                          y: path[path.length - 1].y
                        });
                      }
                
                      // Add the current point to the path
                      path.push({
                        x: point.x,
                        y: point.y
                      });
                    });
                
                    /* not-sparkline:start */
                    // Clip the path
                    path = this.clipPath(path);
                    /* not-sparkline:end */
                
                    // Return the path
                    return path;
                  }
                
                  /**
                   * Calculates the spacing needed for the series.
                   *
                   * @method calculateSpacing
                   * @private
                   * @return {Number} The spacing needed for the series
                   * @since @todo
                   */
                  calculateSpacing() {
                    // Define some local variables
                    let pointSpacing = this.points.visible ?
                      super.calculateSpacing() :
                      {
                        xMin: 0,
                        xMax: 0,
                        yMin: 0,
                        yMax: 0
                      };
                    let lineSpacing = Math.ceil(this.line.lineWidth / 2);
                
                    // Return the larger spacing
                    return {
                      xMin: $Number.max(pointSpacing.xMin, lineSpacing),
                      xMax: $Number.max(pointSpacing.xMax, lineSpacing),
                      yMin: $Number.max(pointSpacing.yMin, lineSpacing),
                      yMax: $Number.max(pointSpacing.yMax, lineSpacing)
                    };
                  }
                
                  /* not-sparkline:start */
                  /**
                   * Clips the draw path to the given zoom.
                   *
                   * @method clipPath
                   * @private
                   * @param {Array} path The draw path
                   * @since @todo
                   */
                  clipPath(path) {
                    // Grab some local pointers
                    let isPointVisible = this.isPointVisible;
                    let spacing = this.calculateSpacing();
                    let xAxis = this.referenceXAxis();
                    let xAxisZoom = xAxis.getCurrentZoom(spacing);
                    let { xMin, xMax } = xAxisZoom;
                    let yAxis = this.referenceYAxis();
                    let yAxisZoom = yAxis.getCurrentZoom(spacing);
                    let { yMin, yMax } = yAxisZoom;
                
                    // Define some local variables
                    let clip = [];
                    let lastPoint;
                    let lastPointIsVisible;
                
                    // Loop through each of the data points
                    $Array.forEach(path, (point, index) =&gt; {
                      // Define some local variables
                      let pointIsInBounds = isPointVisible(point, xAxisZoom, yAxisZoom);
                      let xMinCross;
                      let xMaxCross;
                      let yMinCross;
                      let yMaxCross;
                
                      // If this is not the first point, we need to figure out any cross points
                      if (index &gt; 0) {
                        // Calculate each cross point
                        xMaxCross = xAxis.calculateCross(lastPoint, point, xMax);
                        xMinCross = xAxis.calculateCross(lastPoint, point, xMin);
                        yMaxCross = yAxis.calculateCross(lastPoint, point, yMax);
                        yMinCross = yAxis.calculateCross(lastPoint, point, yMin);
                
                        /* eslint-disable max-depth */
                        // If this point and the next are both in bounds
                        if (pointIsInBounds &amp;&amp; lastPointIsVisible) {
                          // Do nothing...
                        }
                
                        // If this segment goes left to right
                        else if (lastPoint.x &lt; point.x) {
                          if (lastPoint.y &lt; point.y) {
                            if (xMinCross.y &gt;= lastPoint.y &amp;&amp; xMinCross.y &lt;= point.y) {
                              if (xMinCross.y &gt;= yMin &amp;&amp; xMinCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMin,
                                  y: xMinCross.y,
                                  d: &#x27;a&#x27;
                                });
                              }
                              else if (xMinCross.y &lt; yMin &amp;&amp; xMinCross.x &gt;= lastPoint.x &amp;&amp; xMinCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMin,
                                  d: &#x27;b&#x27;
                                });
                              }
                              else if (xMinCross.y &gt; yMax &amp;&amp; xMinCross.x &gt;= lastPoint.x &amp;&amp; xMinCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMax,
                                  d: &#x27;b&#x27;
                                });
                              }
                            }
                
                            if (yMinCross.x &gt;= lastPoint.x &amp;&amp; yMinCross.x &lt;= point.x) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;c&#x27;
                                });
                              }
                            }
                
                            if (yMaxCross.x &gt;= lastPoint.x &amp;&amp; yMaxCross.x &lt;= point.x) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;d&#x27;
                                });
                              }
                            }
                
                            if (xMaxCross.y &gt;= lastPoint.y &amp;&amp; xMaxCross.y &lt;= point.y) {
                              if (xMaxCross.y &gt;= yMin &amp;&amp; xMaxCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMax,
                                  y: xMaxCross.y,
                                  d: &#x27;e&#x27;
                                });
                              }
                              else if (xMaxCross.y &lt; yMin &amp;&amp; xMaxCross.x &gt;= lastPoint.x &amp;&amp; xMaxCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMin,
                                  d: &#x27;f&#x27;
                                });
                              }
                              else if (xMaxCross.y &gt; yMax &amp;&amp; xMaxCross.x &gt;= lastPoint.x &amp;&amp; xMaxCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMax,
                                  d: &#x27;f&#x27;
                                });
                              }
                            }
                          }
                
                          // If this segment goes directly right
                          else if (lastPoint.y === point.y) {
                            // TODO:
                          }
                
                          else if (lastPoint.y &gt; point.y) {
                            if (xMinCross.y &lt;= lastPoint.y &amp;&amp; xMinCross.y &gt;= point.y) {
                              if (xMinCross.y &gt;= yMin &amp;&amp; xMinCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMin,
                                  y: xMinCross.y,
                                  d: &#x27;g&#x27;
                                });
                              }
                              else if (xMinCross.y &lt; yMin &amp;&amp; xMinCross.x &gt;= lastPoint.x &amp;&amp; xMinCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMin,
                                  d: &#x27;h&#x27;
                                });
                              }
                              else if (xMinCross.y &gt; yMax &amp;&amp; xMinCross.x &gt;= lastPoint.x &amp;&amp; xMinCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMax,
                                  d: &#x27;h&#x27;
                                });
                              }
                            }
                
                            if (yMaxCross.x &gt;= lastPoint.x &amp;&amp; yMaxCross.x &lt;= point.x) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;i&#x27;
                                });
                              }
                            }
                
                            if (yMinCross.x &gt;= lastPoint.x &amp;&amp; yMinCross.x &lt;= point.x) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;j&#x27;
                                });
                              }
                            }
                
                            if (xMaxCross.y &lt;= lastPoint.y &amp;&amp; xMaxCross.y &gt;= point.y) {
                              if (xMaxCross.y &gt;= yMin &amp;&amp; xMaxCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMax,
                                  y: xMaxCross.y,
                                  d: &#x27;k&#x27;
                                });
                              }
                              else if (xMaxCross.y &lt; yMin &amp;&amp; xMaxCross.x &gt;= lastPoint.x &amp;&amp; xMaxCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMin,
                                  d: &#x27;l&#x27;
                                });
                              }
                              else if (xMaxCross.y &gt; yMax &amp;&amp; xMaxCross.x &gt;= lastPoint.x &amp;&amp; xMaxCross.x &lt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMax,
                                  d: &#x27;l&#x27;
                                });
                              }
                            }
                          }
                        }
                
                        // If this segment goes directly up or down
                        else if (lastPoint.x === point.x) {
                          // If this segment goes directly up
                          if (lastPoint.y &lt; point.y) {
                            // If this segment crosses the y min value, clip it and add it to the path
                            if (yMinCross.x &gt;= lastPoint.x &amp;&amp; yMinCross.x &lt;= point.x &amp;&amp; yMax &gt;= lastPoint.y &amp;&amp; yMax &lt;= point.y) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;direct up - y min cross&#x27;
                                });
                              }
                            }
                
                            // If this segment crosses the y max value, clip it and add it to the path
                            if (yMaxCross.x &gt;= lastPoint.x &amp;&amp; yMaxCross.x &lt;= point.x &amp;&amp; yMax &gt;= lastPoint.y &amp;&amp; yMax &lt;= point.y) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;direct up - y max cross&#x27;
                                });
                              }
                            }
                          }
                
                          // If the points are exactly the same
                          else if (lastPoint.y === point.y) {
                            // Do nothing...
                          }
                
                          // If this segment goes directly down
                          else if (lastPoint.y &gt; point.y) {
                            // If this segment crosses the y max value, clip it and add it to the path
                            if (yMaxCross.x &gt;= lastPoint.x &amp;&amp; yMaxCross.x &lt;= point.x &amp;&amp; yMax &lt;= lastPoint.y &amp;&amp; yMax &gt;= point.y) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;direct down - y max cross&#x27;
                                });
                              }
                            }
                
                            // If this segment crosses the y min value, clip it and add it to the path
                            if (yMinCross.x &gt;= lastPoint.x &amp;&amp; yMinCross.x &lt;= point.x &amp;&amp; yMin &lt;= lastPoint.y &amp;&amp; yMin &gt;= point.y) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;direct down - y min cross&#x27;
                                });
                              }
                            }
                          }
                        }
                
                        // If this segment goes right to left
                        else if (lastPoint.x &gt; point.x) {
                          if (lastPoint.y &lt; point.y) {
                            if (xMaxCross.y &gt;= lastPoint.y &amp;&amp; xMaxCross.y &lt;= point.y) {
                              if (xMaxCross.y &gt;= yMin &amp;&amp; xMaxCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMax,
                                  y: xMaxCross.y,
                                  d: &#x27;m&#x27;
                                });
                              }
                              else if (xMaxCross.y &lt; yMin &amp;&amp; xMaxCross.x &lt;= lastPoint.x &amp;&amp; xMaxCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMin,
                                  d: &#x27;n&#x27;
                                });
                              }
                              else if (xMaxCross.y &gt; yMax &amp;&amp; xMaxCross.x &lt;= lastPoint.x &amp;&amp; xMaxCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMax,
                                  d: &#x27;n&#x27;
                                });
                              }
                            }
                
                            if (yMinCross.x &lt;= lastPoint.x &amp;&amp; yMinCross.x &gt;= point.x) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;o&#x27;
                                });
                              }
                            }
                
                            if (yMaxCross.x &lt;= lastPoint.x &amp;&amp; yMaxCross.x &gt;= point.x) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;p&#x27;
                                });
                              }
                            }
                
                            if (xMinCross.y &gt;= lastPoint.y &amp;&amp; xMinCross.y &lt;= point.y) {
                              if (xMinCross.y &gt;= yMin &amp;&amp; xMinCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMin,
                                  y: xMinCross.y,
                                  d: &#x27;q&#x27;
                                });
                              }
                              else if (xMinCross.y &lt; yMin &amp;&amp; xMinCross.x &lt;= lastPoint.x &amp;&amp; xMinCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMin,
                                  d: &#x27;r&#x27;
                                });
                              }
                              else if (xMinCross.y &gt; yMax &amp;&amp; xMinCross.x &lt;= lastPoint.x &amp;&amp; xMinCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMax,
                                  d: &#x27;r&#x27;
                                });
                              }
                            }
                          }
                
                          // If this segment goes directly left
                          else if (lastPoint.y === point.y) {
                            // TODO:
                          }
                
                          else if (lastPoint.y &gt; point.y) {
                            if (xMaxCross.y &lt;= lastPoint.y &amp;&amp; xMaxCross.y &gt;= point.y) {
                              if (xMaxCross.y &gt;= yMin &amp;&amp; xMaxCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMax,
                                  y: xMaxCross.y,
                                  d: &#x27;s&#x27;
                                });
                              }
                              else if (xMaxCross.y &lt; yMin &amp;&amp; xMaxCross.x &lt;= lastPoint.x &amp;&amp; xMaxCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMin,
                                  d: &#x27;t&#x27;
                                });
                              }
                              else if (xMaxCross.y &gt; yMax &amp;&amp; xMaxCross.x &lt;= lastPoint.x &amp;&amp; xMaxCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMax,
                                  y: yMax,
                                  d: &#x27;t&#x27;
                                });
                              }
                            }
                
                            if (yMaxCross.x &lt;= lastPoint.x &amp;&amp; yMaxCross.x &gt;= point.x) {
                              if (yMaxCross.x &gt;= xMin &amp;&amp; yMaxCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMaxCross.x,
                                  y: yMax,
                                  d: &#x27;u&#x27;
                                });
                              }
                            }
                
                            if (yMinCross.x &lt;= lastPoint.x &amp;&amp; yMinCross.x &gt;= point.x) {
                              if (yMinCross.x &gt;= xMin &amp;&amp; yMinCross.x &lt;= xMax) {
                                clip.push({
                                  x: yMinCross.x,
                                  y: yMin,
                                  d: &#x27;v&#x27;
                                });
                              }
                            }
                
                            if (xMinCross.y &lt;= lastPoint.y &amp;&amp; xMinCross.y &gt;= point.y) {
                              if (xMinCross.y &gt;= yMin &amp;&amp; xMinCross.y &lt;= yMax) {
                                clip.push({
                                  x: xMin,
                                  y: xMinCross.y,
                                  d: &#x27;w&#x27;
                                });
                              }
                              else if (xMinCross.y &lt; yMin &amp;&amp; xMinCross.x &lt;= lastPoint.x &amp;&amp; xMinCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMin,
                                  d: &#x27;x&#x27;
                                });
                              }
                              else if (xMinCross.y &gt; yMax &amp;&amp; xMinCross.x &lt;= lastPoint.x &amp;&amp; xMinCross.x &gt;= point.x) {
                                clip.push({
                                  x: xMin,
                                  y: yMax,
                                  d: &#x27;x&#x27;
                                });
                              }
                            }
                          }
                        }
                        /* eslint-enable max-depth */
                      }
                
                      // Clamp and push the current point onto the clip
                      clip.push({
                        x: $Number.clamp(point.x, xMin, xMax),
                        y: $Number.clamp(point.y, yMin, yMax),
                        d: &#x27;direct to point&#x27;
                      });
                
                      // Update the last point and if it&#x27;s in bounds
                      lastPoint = point;
                      lastPointIsVisible = isPointVisible(lastPoint, xAxisZoom, yAxisZoom);
                    });
                
                    // console.log(JSON.stringify(clip));
                
                    return clip;
                  }
                  /* not-sparkline:end */
                
                  /**
                   * Draws the series to the chart.
                   *
                   * @method draw
                   * @private
                   * @since @todo
                   */
                  draw() {
                    // Grab some local pointers
                    let chart = this.chart;
                    let xAxis = this.referenceXAxis();
                    let yAxis = this.referenceYAxis();
                    let points = this.buildPath();
                
                    // Begin the drawing path
                    chart.beginPath();
                
                    // Loop through the points of data adding them to the path array
                    $Array.forEach(points, (point, index) =&gt; chart[index === 0 ? &#x27;moveTo&#x27; : &#x27;lineTo&#x27;](
                      xAxis.convertPointToPixel(point.x),
                      yAxis.convertPointToPixel(point.y)
                    ));
                
                    // Draw the line
                    chart.stroke($Object.merge({}, this.line, {
                      strokeStyle: this.line.strokeStyle || this.color
                    }));
                
                    // Draw the points if needed
                    if (this.points.visible === true) {
                      super.draw();
                    }
                  }
                };
                </pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
